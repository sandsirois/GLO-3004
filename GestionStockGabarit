//*******************************************************
//* file GestionStock.pd
//* Gestion des stock de produits vendus au détail
//* auteurs: Jean-François Collin 111084639, Sandra Sirois 990112293,
//*          Christiane St-Cyr 111101565, Alexandre Fortin 910024966
//* date remise 19 avril 2017
//*******************************************************
//////////////////////////////////////////////////////////////////////////
//  à partir d'un gabarit - GLO-3004, spécification formelle et vérification, 
//////////////////////////////////////////////////////////////////////////

//-- Types de base (abstraits) -------------------------------------------
// L'énoncé n'indique aucune information concernant les attributs d'un
//il est alors normal de les considérer comme des types abstraits "tag".
// Les quantités sont naturellement des entiers naturelles. 

class Produit ^= tag;
class Quantite ^= nat;
  



// 


//-- Constantes ----------------------------------------------------------
//  La capacité de stockage est une constante liée aux installations de l'entreprise. 

const 
 capacite : nat ^= 1000;








//------------------------------------------------------------------------
// CLASSE Gestiontock
//------------------------------------------------------------------------
// L'énoncé indique clairement plusieurs attributs et propriétés relatifs
// à la gestion de  stock, il est donc normal d'y associer une classe.	
//--------------------------------------------------------------------------

class GestionStock ^= 

abstract 

var 

// Le stock est une association (produit, quantite)
// Le marcheCible est un ensemble de produits.
// Les seuils sont fournis comme une association (produit,seuil)


  stock          : map of (Produit  -> Quantite),
  marcheCible    : set of (Produit),
  seuil          : map of (Produit -> Quantite),
  renouvellement : map of (Produit -> nat);
  
  
  
invariant

// Les produits en stock doivent faire partie du marche cibe. 
// Le domaine de seuil est le même que le domaine de stock,
// à chaque produit en stock on associe un seuil. 
// Un renouvellement est associé à chacun des produits en stock.
// La quantité de chacun des produits ne doit pas dépasser la capacité de stockage fixée d'avance
// Les seuils ne doivent pas être plus élevés que la capacité de stockage (déduction logique!)
// La quantité en stock de chaque produit doit être supérieur ou égal au seuil minimal associé 
// au produit et inférieure ou égal à la capacité.


     stock.dom <<= marcheCible, 
     seuil.dom =  stock.dom,
     renouvellement.dom = stock.dom,
     forall p::stock.dom :- stock[p] <= capacite,
     forall p::seuil.dom :-  seuil[p] <= capacite,
     forall p::stock.dom :- seuil[p]<= stock[p];
  
   
  
interface

// Puisqu'on passe des paramètres lors de l'initialisation. Il faut s'assurer 
// qu'ils sont conformes aux invariants. 

build{!stock: map of (Produit -> Quantite), !marcheCible :set of (Produit), !seuil:map of (Produit -> Quantite)}

pre
    stock.dom <<= marcheCible,
    seuil.dom =  stock.dom,
    forall p::stock.dom :- stock[p] <= capacite,
    forall p::seuil.dom :-  seuil[p] <= capacite,
    forall p::stock.dom :-  seuil[p] <= stock[p]
     

post

renouvellement!  =  map of (Produit -> nat) {for p ::stock.dom yield pair of (Produit, nat){p,0}}; 

  





schema !achatProduitExistant(p:Produit,q:Quantite)

// Pour pouvoir acheter une quantité q d'un produit existant, 
// Il faut s'assurer que le produit est en stock
// il faut s'assurer que  le total de la quantité existante plus celle qu'on achète reste 
// inférieure ou égale à la capacité

pre 
  p in stock.dom,
  stock[p]+q <= capacite

post 
   stock! = (stock.remove(p)).append(p -> stock[p]+q),
   renouvellement! = (renouvellement.remove(p)).append(p -> renouvellement[p]+q);


                                                    
schema !achatNouveauProduit(p:Produit,q:Quantite,s:Quantite)

// Il faut s'assurer que le produit fait partie du marché cible   
// Pour pouvoir acheter une quantité q d'un produit p non existant en stock, 
// Il faut fournir le seuil  minimal  et il faut s'assurer 
// qu'il est inférieur ou égal à la capacité                                                               
// il faut s'assurer que la quantité  qu'on achète est    
// inférieure ou égale à la capacité et supérieure ou égal au seuil 

                                                                                          
pre 
                                                                                            
  p ~in stock.dom,
  p in marcheCible,
  q <= capacite, 
  s <= capacite,
  s <= q

post
   stock! = stock.append(p -> q),
   seuil! = seuil.append(p -> s),
   renouvellement! = renouvellement.append(p -> 0);



   
schema !venteProduit(p:Produit,q:Quantite)

// Il faut s'assurer que le produit fait partie du stock  
// Pour pouvoir vendre une quantité q d'un produit p existant en stock, 
// Il faut que q soit inférieure ou égale à la capacité 
// Il faut s'assurer que la quantité qui resterait aprés la vente soit supérieure ou égal au seuil                                                         

pre 
  p in stock.dom,
  q <= capacite,
  seuil[p] <= stock[p]-q

post 
   stock! = (stock.remove(p)).append(p -> (stock[p]-q));     
   


schema !venteProduitAchat(p:Produit,q:Quantite)

// Il faut s'assurer que le produit fait partie du stock  
// Pour pouvoir vendre une quantité q  qui fait baisser le stock en deçà du seuil
// Il faut s'assurer que la quantité q vendue soit inférieure ou éagle à capacité mois le seuil minimale
// Il faut commencer par acheter le maximum possible (capacité - stock[p]) puis vendre q. 

    
pre 
  p in stock.dom,
  stock[p]-q < seuil[p],
  q <= capacite-seuil[p]
 

post 
    !achatProduitExistant(p,(capacite-stock[p])) then !venteProduit(p,q);
    

    
schema produitsPopulaires(pp!: set of (Produit),q:Quantite)
 

// Il faut récupérer les produits dont le renouvellement est supérieur ou égal à q


post 
     pp! = (those p::renouvellement.dom :- renouvellement[p] >= q)   
   

     
end;	

// End
